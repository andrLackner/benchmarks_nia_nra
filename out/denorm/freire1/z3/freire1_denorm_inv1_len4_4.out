unsat
((set-logic NIA)
(declare-fun x!0 () Int)
(declare-fun r!1 () Int)
(proof
(let ((?x157 (* 2 x!0)))
 (let ((?x188 (* r!1 r!1)))
 (let ((?x153 (* (- 1) r!1)))
 (let ((?x36 (* r00 r00)))
 (let ((?x99 (* (- 1) ?x36)))
 (let ((?x83 (* (- 2) x00)))
 (let ((?x267 (+ r00 ?x83 ?x99 ?x153 ?x188 ?x157)))
 (let (($x252 (<= ?x267 0)))
 (let (($x257 (= ?x267 0)))
 (let ((?x178 (* (- 2) ?x188)))
 (let ((?x107 (* 4 (* r!1 x!0))))
 (let ((?x101 (* (- 2) (* x!0 x!0))))
 (let ((?x155 (* (+ ?x101 r!1 ?x107 ?x178) ?x267)))
 (let (($x276 (= ?x155 0)))
 (let (($x277 (not $x276)))
 (let (($x154 (and $x257 $x277)))
 (let (($x282 (= (* (+ r!1 ?x178 ?x101 ?x107) (+ ?x153 ?x157 r00 ?x188 ?x83 ?x99)) 0)))
 (let ((?x35 (* 2 x00)))
 (let ((?x114 (* (- 1) r00)))
 (let (($x235 (and (= (+ r!1 (* (- 2) x!0) ?x114 (* (- 1) ?x188) ?x35 ?x36) 0) (not $x282))))
 (let (($x254 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x99 (* (- 1) ?x36)))
 (let ((?x83 (* (- 2) x00)))
 (let ((?x30 (* r r)))
 (let ((?x32 (* 2 x)))
 (let ((?x62 (* (- 1) r)))
 (let ((?x105 (+ ?x62 ?x32 r00 ?x30 ?x83 ?x99)))
 (let ((?x281 (+ r (* (- 2) ?x30) (* (- 2) (* x x)) (* 4 (* r x)))))
 (let ((?x35 (* 2 x00)))
 (let ((?x115 (* (- 1) ?x30)))
 (let ((?x114 (* (- 1) r00)))
 (let ((?x113 (* (- 2) x)))
 (let (($x117 (= (+ r ?x113 ?x114 ?x115 ?x35 ?x36) 0)))
 (and $x117 (not (= (* ?x281 ?x105) 0)))))))))))))))) :qid k!26))
 ))
 (let (($x226 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x99 (* (- 1) ?x36)))
 (let ((?x83 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x156 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x83 ?x99)))
 (let ((?x96 (+ r (* (- 2) (* (+ x (* (- 1) r)) (+ x (* (- 1) r)))))))
 (let (($x89 (not (= (* ?x96 ?x156) 0))))
 (let ((?x35 (* 2 x00)))
 (let ((?x113 (* (- 2) x)))
 (let ((?x30 (* r r)))
 (let ((?x115 (* (- 1) ?x30)))
 (let ((?x114 (* (- 1) r00)))
 (and (= (+ r ?x114 ?x115 ?x113 ?x35 ?x36) 0) $x89))))))))))))) :qid k!26))
 ))
 (let ((?x174 (lambda ((r Int) (x Int) )(let ((?x36 (* r00 r00)))
 (let ((?x99 (* (- 1) ?x36)))
 (let ((?x83 (* (- 2) x00)))
 (let ((?x30 (* r r)))
 (let ((?x32 (* 2 x)))
 (let ((?x62 (* (- 1) r)))
 (let ((?x105 (+ ?x62 ?x32 r00 ?x30 ?x83 ?x99)))
 (let ((?x281 (+ r (* (- 2) ?x30) (* (- 2) (* x x)) (* 4 (* r x)))))
 (let ((?x35 (* 2 x00)))
 (let ((?x115 (* (- 1) ?x30)))
 (let ((?x114 (* (- 1) r00)))
 (let ((?x113 (* (- 2) x)))
 (let (($x117 (= (+ r ?x113 ?x114 ?x115 ?x35 ?x36) 0)))
 (let (($x150 (and $x117 (not (= (* ?x281 ?x105) 0)))))
 (let ((?x156 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x83 ?x99)))
 (let (($x112 (= (* (+ r (* (- 2) (* (+ x ?x62) (+ x ?x62)))) ?x156) 0)))
 (let (($x89 (not $x112)))
 (let (($x265 (and (= (+ r ?x114 ?x115 ?x113 ?x35 ?x36) 0) $x89)))
 (rewrite (= $x265 $x150)))))))))))))))))))))
 ))
 (let (($x106 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x99 (* (- 1) ?x36)))
 (let ((?x83 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x156 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x83 ?x99)))
 (let ((?x96 (+ r (* (- 2) (* (+ x (* (- 1) r)) (+ x (* (- 1) r)))))))
 (let (($x89 (not (= (* ?x96 ?x156) 0))))
 (and (= (+ (* (- 1) r) r00 (* r r) ?x32 ?x83 ?x99) 0) $x89)))))))) :qid k!26))
 ))
 (let ((?x244 (lambda ((r Int) (x Int) )(let ((?x36 (* r00 r00)))
 (let ((?x99 (* (- 1) ?x36)))
 (let ((?x83 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x156 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x83 ?x99)))
 (let ((?x96 (+ r (* (- 2) (* (+ x (* (- 1) r)) (+ x (* (- 1) r)))))))
 (let (($x89 (not (= (* ?x96 ?x156) 0))))
 (let ((?x35 (* 2 x00)))
 (let ((?x113 (* (- 2) x)))
 (let ((?x30 (* r r)))
 (let ((?x115 (* (- 1) ?x30)))
 (let ((?x114 (* (- 1) r00)))
 (let (($x265 (and (= (+ r ?x114 ?x115 ?x113 ?x35 ?x36) 0) $x89)))
 (let (($x260 (and (= (+ (* (- 1) r) r00 ?x30 ?x32 ?x83 ?x99) 0) $x89)))
 (rewrite (= $x260 $x265)))))))))))))))))
 ))
 (let (($x57 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x35 (* 2 x00)))
 (let ((?x46 (+ (* (- 1) (+ r 1)) r00 (* (+ r 1) (+ r 1)) (* 2 (- x r)))))
 (let ((?x52 (* (- (- ?x46 ?x35) ?x36) (- (+ (- 1) r 1) (* 2 (- x r) (- x r))))))
 (let ((?x38 (- (- (+ (* (- 1) r) r00 (* r r) (* 2 x)) ?x35) ?x36)))
 (and (= ?x38 0) (or (not (= ?x52 0))))))))) :qid k!26))
 ))
 (let ((?x221 (lambda ((r Int) (x Int) )(let ((?x36 (* r00 r00)))
 (let ((?x99 (* (- 1) ?x36)))
 (let ((?x83 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x156 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x83 ?x99)))
 (let ((?x96 (+ r (* (- 2) (* (+ x (* (- 1) r)) (+ x (* (- 1) r)))))))
 (let (($x89 (not (= (* ?x96 ?x156) 0))))
 (let (($x260 (and (= (+ (* (- 1) r) r00 (* r r) ?x32 ?x83 ?x99) 0) $x89)))
 (let ((?x35 (* 2 x00)))
 (let ((?x46 (+ (* (- 1) (+ r 1)) r00 (* (+ r 1) (+ r 1)) (* 2 (- x r)))))
 (let ((?x52 (* (- (- ?x46 ?x35) ?x36) (- (+ (- 1) r 1) (* 2 (- x r) (- x r))))))
 (let (($x40 (= (- (- (+ (* (- 1) r) r00 (* r r) ?x32) ?x35) ?x36) 0)))
 (let (($x56 (and $x40 (or (not (= ?x52 0))))))
 (rewrite (= $x56 $x260))))))))))))))))
 ))
 (let ((@x58 (asserted $x57)))
 (let ((@x250 (mp (mp @x58 (quant-intro (proof-bind ?x221) (= $x57 $x106)) $x106) (rewrite (= $x106 $x106)) $x106)))
 (let ((@x238 (mp (mp @x250 (quant-intro (proof-bind ?x244) (= $x106 $x226)) $x226) (quant-intro (proof-bind ?x174) (= $x226 $x254)) $x254)))
 (let ((@x74 (mp (mp~ @x238 (sk (~ $x254 $x235)) $x235) (rewrite (= $x235 $x154)) $x154)))
 (let ((@x145 (and-elim @x74 $x257)))
 (let ((@x256 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x257) $x252)) @x145 $x252)))
 (let (($x253 (>= ?x267 0)))
 (let ((@x143 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x257) $x253)) @x145 $x253)))
 (let (($x262 (not (>= ?x155 0))))
 (let (($x190 (<= ?x155 0)))
 (let ((@x61 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x276 (not $x190) $x262)) (and-elim @x74 $x277) (or (not $x190) $x262))))
 (let ((@x60 (unit-resolution @x61 (lemma ((_ th-lemma arith farkas 1 1 1) (hypothesis (not $x190)) @x143 @x256 false) $x190) $x262)))
 ((_ th-lemma arith farkas 1 1 1) @x60 @x143 @x256 false))))))))))))))))))))))))))))))))))))))))))

(:added-eqs                 1
 :arith-assert-diseq        1
 :arith-assert-lower        5
 :arith-assert-upper        4
 :arith-conflicts           2
 :arith-eq-adapter          2
 :arith-num-rows            2
 :arith-pseudo-nonlinear    2
 :arith-tableau-max-columns 15
 :arith-tableau-max-rows    2
 :conflicts                 2
 :decisions                 1
 :del-clause                5
 :max-memory                3.45
 :memory                    3.04
 :mk-bool-var               12
 :mk-clause                 7
 :num-allocs                1048938
 :num-checks                1
 :propagations              4
 :rlimit-count              1027
 :time                      0.01
 :total-time                0.01)
