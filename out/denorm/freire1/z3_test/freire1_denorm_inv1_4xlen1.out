unsat
((set-logic NIA)
(declare-fun r!1 () Int)
(declare-fun x!0 () Int)
(proof
(let ((?x121 (* (- 1) r!1)))
 (let ((?x127 (* 2 x!0)))
 (let ((?x141 (* r!1 r!1)))
 (let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x87 (+ r00 ?x80 ?x96 ?x141 ?x127 ?x121)))
 (let (($x298 (<= ?x87 0)))
 (let (($x98 (= ?x87 0)))
 (let ((?x89 (+ x!0 ?x121)))
 (let ((?x181 (+ 1 r!1)))
 (let ((?x287 (* ?x181 ?x181 ?x181 ?x181 ?x181 ?x89 ?x89 ?x89 ?x89 ?x89 ?x87)))
 (let (($x285 (= ?x287 0)))
 (let (($x288 (not $x285)))
 (let (($x286 (and $x98 $x288)))
 (let ((?x187 (+ ?x121 x!0)))
 (let ((?x63 (* ?x181 ?x181 ?x181 ?x181 ?x181 ?x187 ?x187 ?x187 ?x187 ?x187 (+ ?x121 ?x127 r00 ?x141 ?x80 ?x96))))
 (let ((?x35 (* 2 x00)))
 (let ((?x111 (* (- 1) r00)))
 (let (($x92 (and (= (+ r!1 (* (- 2) x!0) ?x111 (* (- 1) ?x141) ?x35 ?x36) 0) (not (= ?x63 0)))))
 (let (($x283 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x30 (* r r)))
 (let ((?x32 (* 2 x)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x102 (+ ?x59 ?x32 r00 ?x30 ?x80 ?x96)))
 (let ((?x167 (+ ?x59 x)))
 (let ((?x119 (+ 1 r)))
 (let (($x147 (= (* ?x119 ?x119 ?x119 ?x119 ?x119 ?x167 ?x167 ?x167 ?x167 ?x167 ?x102) 0)))
 (let ((?x35 (* 2 x00)))
 (let ((?x111 (* (- 1) r00)))
 (let (($x114 (= (+ r (* (- 2) x) ?x111 (* (- 1) ?x30) ?x35 ?x36) 0)))
 (and $x114 (not $x147))))))))))))))) :qid k!26))
 ))
 (let (($x199 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x135 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x80 ?x96)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x168 (+ x ?x59)))
 (let ((?x119 (+ 1 r)))
 (let (($x193 (= (* ?x119 ?x119 ?x119 ?x119 ?x119 ?x168 ?x168 ?x168 ?x168 ?x168 ?x135) 0)))
 (and (= (+ ?x59 r00 (* r r) ?x32 ?x80 ?x96) 0) (not $x193))))))))))) :qid k!26))
 ))
 (let ((?x100 (lambda ((r Int) (x Int) )(let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x30 (* r r)))
 (let ((?x32 (* 2 x)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x102 (+ ?x59 ?x32 r00 ?x30 ?x80 ?x96)))
 (let ((?x167 (+ ?x59 x)))
 (let ((?x119 (+ 1 r)))
 (let (($x147 (= (* ?x119 ?x119 ?x119 ?x119 ?x119 ?x167 ?x167 ?x167 ?x167 ?x167 ?x102) 0)))
 (let ((?x35 (* 2 x00)))
 (let ((?x111 (* (- 1) r00)))
 (let (($x114 (= (+ r (* (- 2) x) ?x111 (* (- 1) ?x30) ?x35 ?x36) 0)))
 (let (($x140 (and $x114 (not $x147))))
 (let ((?x168 (+ x ?x59)))
 (let ((?x180 (* ?x119 ?x119 ?x119 ?x119 ?x119 ?x168 ?x168 ?x168 ?x168 ?x168 (+ (- 1) (* (- 3) r) r00 (* ?x119 ?x119) ?x32 ?x80 ?x96))))
 (let (($x142 (and (= (+ ?x59 r00 ?x30 ?x32 ?x80 ?x96) 0) (not (= ?x180 0)))))
 (rewrite (= $x142 $x140))))))))))))))))))))
 ))
 (let (($x54 (exists ((r Int) (x Int) )(! (let ((?x44 (- x r)))
 (let ((?x27 (- 1)))
 (let ((?x41 (+ r 1)))
 (let ((?x36 (* r00 r00)))
 (let ((?x35 (* 2 x00)))
 (let ((?x48 (- (- (+ (* ?x27 ?x41) r00 (* ?x41 ?x41) (* 2 ?x44)) ?x35) ?x36)))
 (let ((?x49 (* ?x48 ?x41 ?x41 ?x44 ?x27 ?x41 ?x41 ?x41 ?x27 ?x44 ?x27 ?x44 ?x44 ?x44)))
 (let ((?x38 (- (- (+ (* ?x27 r) r00 (* r r) (* 2 x)) ?x35) ?x36)))
 (and (= ?x38 0) (or (not (= ?x49 0)))))))))))) :qid k!26))
 ))
 (let ((?x201 (lambda ((r Int) (x Int) )(let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x135 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x80 ?x96)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x168 (+ x ?x59)))
 (let ((?x119 (+ 1 r)))
 (let (($x193 (= (* ?x119 ?x119 ?x119 ?x119 ?x119 ?x168 ?x168 ?x168 ?x168 ?x168 ?x135) 0)))
 (let (($x142 (and (= (+ ?x59 r00 (* r r) ?x32 ?x80 ?x96) 0) (not $x193))))
 (let ((?x44 (- x r)))
 (let ((?x27 (- 1)))
 (let ((?x41 (+ r 1)))
 (let ((?x35 (* 2 x00)))
 (let ((?x48 (- (- (+ (* ?x27 ?x41) r00 (* ?x41 ?x41) (* 2 ?x44)) ?x35) ?x36)))
 (let ((?x49 (* ?x48 ?x41 ?x41 ?x44 ?x27 ?x41 ?x41 ?x41 ?x27 ?x44 ?x27 ?x44 ?x44 ?x44)))
 (let (($x40 (= (- (- (+ (* ?x27 r) r00 (* r r) ?x32) ?x35) ?x36) 0)))
 (let (($x53 (and $x40 (or (not (= ?x49 0))))))
 (rewrite (= $x53 $x142)))))))))))))))))))))
 ))
 (let ((@x55 (asserted $x54)))
 (let ((@x143 (mp (mp @x55 (quant-intro (proof-bind ?x201) (= $x54 $x199)) $x199) (rewrite (= $x199 $x199)) $x199)))
 (let ((@x104 (mp~ (mp @x143 (quant-intro (proof-bind ?x100) (= $x199 $x283)) $x283) (sk (~ $x283 $x92)) $x92)))
 (let ((@x276 (mp @x104 (rewrite (= $x92 $x286)) $x286)))
 (let ((@x278 (and-elim @x276 $x98)))
 (let ((@x307 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x98) $x298)) @x278 $x298)))
 (let (($x299 (>= ?x87 0)))
 (let ((@x310 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x98) $x299)) @x278 $x299)))
 (let (($x318 (not (>= ?x287 0))))
 (let (($x300 (<= ?x287 0)))
 (let ((@x323 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x285 (not $x300) $x318)) (and-elim @x276 $x288) (or (not $x300) $x318))))
 (let ((@x324 (unit-resolution @x323 (lemma ((_ th-lemma arith farkas 1 1 1) (hypothesis (not $x300)) @x310 @x307 false) $x300) $x318)))
 ((_ th-lemma arith farkas 1 1 1) @x324 @x310 @x307 false))))))))))))))))))))))))))))))))))))))))

(:added-eqs                 1
 :arith-assert-diseq        1
 :arith-assert-lower        5
 :arith-assert-upper        4
 :arith-conflicts           2
 :arith-eq-adapter          2
 :arith-num-rows            3
 :arith-pseudo-nonlinear    2
 :arith-tableau-max-columns 14
 :arith-tableau-max-rows    3
 :conflicts                 2
 :decisions                 1
 :del-clause                5
 :max-memory                19.48
 :memory                    19.16
 :mk-bool-var               6
 :mk-clause                 7
 :num-allocs                419770
 :num-checks                1
 :propagations              4
 :rlimit-count              701
 :time                      0.01
 :total-time                0.02)
