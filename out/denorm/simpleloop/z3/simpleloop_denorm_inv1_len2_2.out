unsat
((set-logic NIA)
(declare-fun x!1 () Int)
(declare-fun y!0 () Int)
(proof
(let ((?x302 (+ y00 x00 (* (- 1) y!0) (* (- 1) x!1))))
 (let (($x153 (<= ?x302 0)))
 (let (($x140 (= ?x302 0)))
 (let ((?x91 (+ (* y00 y!0 x!1) (* (- 4) (* y!0 y!0 x!1)) (* x00 y!0 x!1) (* 3 (* y00 y!0 y!0)) (* 3 (* x00 y!0 y!0)) (* (- 1) (* y!0 y!0 y!0 x!1)) (* 2 (* x00 y!0)) (* (- 1) (* y!0 x!1 x!1)) (* y00 x!1) (* x00 x!1) (* 2 (* y00 y!0)) (* y00 y!0 y!0 y!0) (* (- 1) (* y!0 y!0 y!0 y!0)) (* (- 1) (* x!1 x!1)) (* (- 2) (* y!0 y!0)) (* (- 3) (* y!0 y!0 y!0)) (* x00 y!0 y!0 y!0) (* (- 3) (* y!0 x!1)))))
 (let (($x94 (= ?x91 0)))
 (let (($x102 (not $x94)))
 (let (($x309 (and $x140 $x102)))
 (let ((?x202 (* y!0 y!0 y!0 y!0)))
 (let ((?x212 (* x!1 x!1)))
 (let ((?x149 (+ (* 3 (* x!1 y!0)) (* 2 (* y!0 y!0)) (* 3 (* y!0 y!0 y!0)) ?x212 (* (- 1) (* x!1 y00)) (* (- 1) (* x!1 x00)) (* (- 2) (* y!0 y00)) (* (- 2) (* y!0 x00)) (* x!1 x!1 y!0) (* 4 (* x!1 y!0 y!0)) (* (- 1) (* x!1 y!0 y00)) (* (- 1) (* x!1 y!0 x00)) (* (- 3) (* y!0 y!0 y00)) (* (- 3) (* y!0 y!0 x00)) (* x!1 y!0 y!0 y!0) ?x202 (* (- 1) (* y!0 y!0 y!0 y00)) (* (- 1) (* y!0 y!0 y!0 x00)))))
 (let (($x135 (and (= (+ x!1 y!0 (* (- 1) y00) (* (- 1) x00)) 0) (not (= ?x149 0)))))
 (let (($x75 (exists ((x Int) (y Int) )(! (let ((?x306 (+ (* 3 (* x y)) (* 2 (* y y)) (* 3 (* y y y)) (* x x) (* (- 1) (* x y00)) (* (- 1) (* x x00)) (* (- 2) (* y y00)) (* (- 2) (* y x00)) (* x x y) (* 4 (* x y y)) (* (- 1) (* x y y00)) (* (- 1) (* x y x00)) (* (- 3) (* y y y00)) (* (- 3) (* y y x00)) (* x y y y) (* y y y y) (* (- 1) (* y y y y00)) (* (- 1) (* y y y x00)))))
 (and (= (+ x y (* (- 1) y00) (* (- 1) x00)) 0) (not (= ?x306 0)))) :qid k!26))
 ))
 (let (($x235 (exists ((x Int) (y Int) )(! (let ((?x57 (* (- 1) x00)))
 (let ((?x50 (* (- 1) y00)))
 (let ((?x226 (+ x ?x50 ?x57 y)))
 (let ((?x277 (+ (* (+ (- 1) x) (+ 1 y)) (* (+ 1 y) (+ 1 y) (+ 1 y)))))
 (and (= ?x226 0) (not (= (* ?x277 ?x226) 0))))))) :qid k!26))
 ))
 (let ((?x216 (lambda ((x Int) (y Int) )(let ((?x306 (+ (* 3 (* x y)) (* 2 (* y y)) (* 3 (* y y y)) (* x x) (* (- 1) (* x y00)) (* (- 1) (* x x00)) (* (- 2) (* y y00)) (* (- 2) (* y x00)) (* x x y) (* 4 (* x y y)) (* (- 1) (* x y y00)) (* (- 1) (* x y x00)) (* (- 3) (* y y y00)) (* (- 3) (* y y x00)) (* x y y y) (* y y y y) (* (- 1) (* y y y y00)) (* (- 1) (* y y y x00)))))
 (let (($x89 (and (= (+ x y (* (- 1) y00) (* (- 1) x00)) 0) (not (= ?x306 0)))))
 (let ((?x57 (* (- 1) x00)))
 (let ((?x50 (* (- 1) y00)))
 (let ((?x226 (+ x ?x50 ?x57 y)))
 (let ((?x277 (+ (* (+ (- 1) x) (+ 1 y)) (* (+ 1 y) (+ 1 y) (+ 1 y)))))
 (let (($x247 (and (= ?x226 0) (not (= (* ?x277 ?x226) 0)))))
 (rewrite (= $x247 $x89))))))))))
 ))
 (let (($x47 (exists ((x Int) (y Int) )(! (let ((?x41 (+ (* (- x 1) (+ y 1)) (* (+ y 1) (+ y 1) (+ y 1)))))
 (let (($x43 (= (* (+ (- (- (- x 1) y00) x00) y 1) ?x41) 0)))
 (and (= (+ (- (- x y00) x00) y) 0) (or (not $x43))))) :qid k!26))
 ))
 (let ((?x237 (lambda ((x Int) (y Int) )(let ((?x57 (* (- 1) x00)))
 (let ((?x50 (* (- 1) y00)))
 (let ((?x226 (+ x ?x50 ?x57 y)))
 (let ((?x277 (+ (* (+ (- 1) x) (+ 1 y)) (* (+ 1 y) (+ 1 y) (+ 1 y)))))
 (let (($x247 (and (= ?x226 0) (not (= (* ?x277 ?x226) 0)))))
 (let ((?x41 (+ (* (- x 1) (+ y 1)) (* (+ y 1) (+ y 1) (+ y 1)))))
 (let (($x43 (= (* (+ (- (- (- x 1) y00) x00) y 1) ?x41) 0)))
 (let (($x46 (and (= (+ (- (- x y00) x00) y) 0) (or (not $x43)))))
 (rewrite (= $x46 $x247)))))))))))
 ))
 (let ((@x48 (asserted $x47)))
 (let ((@x258 (mp (mp @x48 (quant-intro (proof-bind ?x237) (= $x47 $x235)) $x235) (rewrite (= $x235 $x235)) $x235)))
 (let ((@x203 (mp~ (mp @x258 (quant-intro (proof-bind ?x216) (= $x235 $x75)) $x75) (sk (~ $x75 $x135)) $x135)))
 (let ((@x103 (mp @x203 (rewrite (= $x135 $x309)) $x309)))
 (let ((@x105 (and-elim @x103 $x140)))
 (let ((@x279 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x140) $x153)) @x105 $x153)))
 (let (($x300 (>= ?x302 0)))
 (let ((@x271 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x140) $x300)) @x105 $x300)))
 (let (($x282 (not (>= ?x91 0))))
 (let (($x154 (<= ?x91 0)))
 (let ((@x294 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x94 (not $x154) $x282)) (and-elim @x103 $x102) (or (not $x154) $x282))))
 (let ((@x295 (unit-resolution @x294 (lemma ((_ th-lemma arith) (hypothesis (not $x154)) @x271 @x279 false) $x154) $x282)))
 ((_ th-lemma arith) @x295 @x271 @x279 false)))))))))))))))))))))))))))))))

(:added-eqs                 1
 :arith-assert-diseq        1
 :arith-assert-lower        9
 :arith-assert-upper        3
 :arith-conflicts           2
 :arith-eq-adapter          2
 :arith-grobner             2
 :arith-max-min             170
 :arith-nonlinear-bounds    6
 :arith-nonlinear-horner    4
 :arith-num-rows            2
 :arith-pivots              2
 :arith-tableau-max-columns 31
 :arith-tableau-max-rows    2
 :conflicts                 2
 :decisions                 1
 :del-clause                7
 :final-checks              4
 :max-memory                3.57
 :memory                    3.09
 :mk-bool-var               12
 :mk-clause                 7
 :num-allocs                1103433
 :num-checks                1
 :propagations              4
 :rlimit-count              2100
 :time                      0.01
 :total-time                0.01)
