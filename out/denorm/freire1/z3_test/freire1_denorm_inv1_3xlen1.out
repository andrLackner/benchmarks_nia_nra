unsat
((set-logic NIA)
(declare-fun x!0 () Int)
(declare-fun r!1 () Int)
(proof
(let ((?x93 (* 2 x!0)))
 (let ((?x130 (* r!1 r!1)))
 (let ((?x150 (* (- 1) r!1)))
 (let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x74 (+ r00 ?x80 ?x96 ?x150 ?x130 ?x93)))
 (let (($x281 (<= ?x74 0)))
 (let (($x164 (= ?x74 0)))
 (let ((?x92 (+ ?x150 x!0)))
 (let ((?x75 (+ 1 r!1)))
 (let ((?x272 (* ?x75 ?x75 ?x75 ?x75 ?x92 ?x92 ?x92 ?x92 ?x92 ?x92 ?x74)))
 (let (($x133 (= ?x272 0)))
 (let (($x273 (not $x133)))
 (let (($x151 (and $x164 $x273)))
 (let ((?x98 (* ?x75 ?x75 ?x75 ?x75 ?x92 ?x92 ?x92 ?x92 ?x92 ?x92 (+ ?x150 ?x93 r00 ?x130 ?x80 ?x96))))
 (let ((?x35 (* 2 x00)))
 (let ((?x111 (* (- 1) r00)))
 (let (($x101 (and (= (+ r!1 (* (- 2) x!0) ?x111 (* (- 1) ?x130) ?x35 ?x36) 0) (not (= ?x98 0)))))
 (let (($x271 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x30 (* r r)))
 (let ((?x32 (* 2 x)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x102 (+ ?x59 ?x32 r00 ?x30 ?x80 ?x96)))
 (let ((?x167 (+ ?x59 x)))
 (let ((?x119 (+ 1 r)))
 (let (($x166 (= (* ?x119 ?x119 ?x119 ?x119 ?x167 ?x167 ?x167 ?x167 ?x167 ?x167 ?x102) 0)))
 (let ((?x35 (* 2 x00)))
 (let ((?x111 (* (- 1) r00)))
 (let (($x114 (= (+ r (* (- 2) x) ?x111 (* (- 1) ?x30) ?x35 ?x36) 0)))
 (and $x114 (not $x166))))))))))))))) :qid k!26))
 ))
 (let (($x83 (exists ((r Int) (x Int) )(! (let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x144 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x80 ?x96)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x168 (+ x ?x59)))
 (let ((?x119 (+ 1 r)))
 (let (($x183 (= (* ?x119 ?x119 ?x119 ?x119 ?x168 ?x168 ?x168 ?x168 ?x168 ?x168 ?x144) 0)))
 (and (= (+ ?x59 r00 (* r r) ?x32 ?x80 ?x96) 0) (not $x183))))))))))) :qid k!26))
 ))
 (let ((?x82 (lambda ((r Int) (x Int) )(let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x30 (* r r)))
 (let ((?x32 (* 2 x)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x102 (+ ?x59 ?x32 r00 ?x30 ?x80 ?x96)))
 (let ((?x167 (+ ?x59 x)))
 (let ((?x119 (+ 1 r)))
 (let (($x166 (= (* ?x119 ?x119 ?x119 ?x119 ?x167 ?x167 ?x167 ?x167 ?x167 ?x167 ?x102) 0)))
 (let ((?x35 (* 2 x00)))
 (let ((?x111 (* (- 1) r00)))
 (let (($x114 (= (+ r (* (- 2) x) ?x111 (* (- 1) ?x30) ?x35 ?x36) 0)))
 (let (($x170 (and $x114 (not $x166))))
 (let ((?x168 (+ x ?x59)))
 (let ((?x177 (* ?x119 ?x119 ?x119 ?x119 ?x168 ?x168 ?x168 ?x168 ?x168 ?x168 (+ (- 1) (* (- 3) r) r00 (* ?x119 ?x119) ?x32 ?x80 ?x96))))
 (let (($x153 (and (= (+ ?x59 r00 ?x30 ?x32 ?x80 ?x96) 0) (not (= ?x177 0)))))
 (rewrite (= $x153 $x170))))))))))))))))))))
 ))
 (let (($x54 (exists ((r Int) (x Int) )(! (let ((?x44 (- x r)))
 (let ((?x41 (+ r 1)))
 (let ((?x36 (* r00 r00)))
 (let ((?x35 (* 2 x00)))
 (let ((?x48 (- (- (+ (* (- 1) ?x41) r00 (* ?x41 ?x41) (* 2 ?x44)) ?x35) ?x36)))
 (let (($x50 (= (* ?x48 ?x41 ?x41 ?x41 ?x44 ?x44 ?x44 ?x41 ?x44 ?x44 ?x44) 0)))
 (let ((?x38 (- (- (+ (* (- 1) r) r00 (* r r) (* 2 x)) ?x35) ?x36)))
 (and (= ?x38 0) (or (not $x50)))))))))) :qid k!26))
 ))
 (let ((?x97 (lambda ((r Int) (x Int) )(let ((?x36 (* r00 r00)))
 (let ((?x96 (* (- 1) ?x36)))
 (let ((?x80 (* (- 2) x00)))
 (let ((?x32 (* 2 x)))
 (let ((?x144 (+ (- 1) (* (- 3) r) r00 (* (+ 1 r) (+ 1 r)) ?x32 ?x80 ?x96)))
 (let ((?x59 (* (- 1) r)))
 (let ((?x168 (+ x ?x59)))
 (let ((?x119 (+ 1 r)))
 (let (($x183 (= (* ?x119 ?x119 ?x119 ?x119 ?x168 ?x168 ?x168 ?x168 ?x168 ?x168 ?x144) 0)))
 (let (($x153 (and (= (+ ?x59 r00 (* r r) ?x32 ?x80 ?x96) 0) (not $x183))))
 (let ((?x44 (- x r)))
 (let ((?x41 (+ r 1)))
 (let ((?x35 (* 2 x00)))
 (let ((?x48 (- (- (+ (* (- 1) ?x41) r00 (* ?x41 ?x41) (* 2 ?x44)) ?x35) ?x36)))
 (let (($x50 (= (* ?x48 ?x41 ?x41 ?x41 ?x44 ?x44 ?x44 ?x41 ?x44 ?x44 ?x44) 0)))
 (let (($x40 (= (- (- (+ (* (- 1) r) r00 (* r r) ?x32) ?x35) ?x36) 0)))
 (let (($x53 (and $x40 (or (not $x50)))))
 (rewrite (= $x53 $x153))))))))))))))))))))
 ))
 (let ((@x55 (asserted $x54)))
 (let ((@x146 (mp (mp @x55 (quant-intro (proof-bind ?x97) (= $x54 $x83)) $x83) (rewrite (= $x83 $x83)) $x83)))
 (let ((@x88 (mp~ (mp @x146 (quant-intro (proof-bind ?x82) (= $x83 $x271)) $x271) (sk (~ $x271 $x101)) $x101)))
 (let ((@x267 (mp @x88 (rewrite (= $x101 $x151)) $x151)))
 (let ((@x269 (and-elim @x267 $x164)))
 (let ((@x290 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x164) $x281)) @x269 $x281)))
 (let (($x282 (>= ?x74 0)))
 (let ((@x293 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x164) $x282)) @x269 $x282)))
 (let (($x298 (not (>= ?x272 0))))
 (let (($x283 (<= ?x272 0)))
 (let ((@x302 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x133 (not $x283) $x298)) (and-elim @x267 $x273) (or (not $x283) $x298))))
 (let ((@x303 (unit-resolution @x302 (lemma ((_ th-lemma arith farkas 1 1 1) (hypothesis (not $x283)) @x293 @x290 false) $x283) $x298)))
 ((_ th-lemma arith farkas 1 1 1) @x303 @x293 @x290 false)))))))))))))))))))))))))))))))))))))))

(:added-eqs                 1
 :arith-assert-diseq        1
 :arith-assert-lower        5
 :arith-assert-upper        4
 :arith-conflicts           2
 :arith-eq-adapter          2
 :arith-num-rows            3
 :arith-pseudo-nonlinear    2
 :arith-tableau-max-columns 14
 :arith-tableau-max-rows    3
 :conflicts                 2
 :decisions                 1
 :del-clause                5
 :max-memory                19.45
 :memory                    19.13
 :mk-bool-var               6
 :mk-clause                 7
 :num-allocs                419854
 :num-checks                1
 :propagations              4
 :rlimit-count              693
 :time                      0.01
 :total-time                0.02)
